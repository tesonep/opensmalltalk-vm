Object subclass: #EmbeddedSupport	instanceVariableNames: ''	classVariableNames: ''	package: 'Embedded-Support'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbeddedSupport class	instanceVariableNames: ''!!EmbeddedSupport class methodsFor: 'testing' stamp: 'PabloTesone 10/14/2019 16:15'!isEmbedded 	^ Smalltalk argumentsInclude: '--embedded'		! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.049144 pm'!!OSWorldRenderer methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 15:06'!windowTitle	^ EmbeddedSupport isEmbedded		ifTrue: [ 'Embedded image in working directory: ' , FileLocator workingDirectory fullName ]		ifFalse: [ Smalltalk image imageFile fullName ]! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.051144 pm'!!OSWorldRenderer methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 14:59'!doActivate	| attributes initialExtent |		initialExtent := world worldState realWindowExtent ifNil: [976@665].	attributes := OSWindowAttributes new.	attributes		extent: initialExtent;		title: (self windowTitle);		windowCentered:true;		icon: (self iconNamed: #pharoBig).	display := Form extent: initialExtent depth: 32.	world extent: initialExtent.	driver := self pickMostSuitableWindowDriver.	attributes preferableDriver: driver.	osWindow := OSWindow createWithAttributes: attributes eventHandler: (OSWindowMorphicEventHandler for: world).		osWindow focus. 		world worldState doFullRepaint.	world displayWorld.		OSWindowClipboard new beDefault.! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.052144 pm'!!PharoFilesOpener methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 15:28'!informProblemInChanges: msg	"If I am embedded I have no sources!! "	EmbeddedSupport isEmbedded ifTrue: [ ^ self ].	self inform: msg withChangesRef: self changesName! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.053144 pm'!!PharoFilesOpener methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 16:25'!shouldInformAboutReadOnlyChanges	"If I am embedded I have no sources!! "	EmbeddedSupport isEmbedded ifTrue: [ ^ false ].	"Answer true if and only if the user must be informed when the .changes file can not be written to."	^ shouldInformAboutReadOnlyChanges ifNil: [ shouldInformAboutReadOnlyChanges := true ]! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.053144 pm'!!PharoFilesOpener methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 16:27'!informCannotLocateSources	| msg |		EmbeddedSupport isEmbedded ifTrue: [ ^self ].		msg := self cannotLocateMsg.	Smalltalk os isMacOS		ifTrue: [ 			msg := msg				,					'Make sure the sources file is not an Alias.' ].	self inform: msg withSourceRef: self sourcesName! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.053144 pm'!!SmalltalkImage methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 15:19'!snapshot: save andQuit: quit		(SessionManager default currentSession isReadOnlyAccessMode and: [ save ])		ifTrue: [ self error: 'Cannot save, in a read only image.' ].	DefaultExecutionEnvironment beActiveDuring: 		 [^SessionManager default snapshot: save andQuit: quit]! !'From Pharo8.0.0 of 13 October 2019 [Build information: Pharo-8.0.0+build.867.sha.6ba2551d782ddcb38ddc87000fe1d168254fdb85 (64 Bit)] on 14 October 2019 at 5:22:05.054144 pm'!!OmFileStore methodsFor: '*Embedded-Support' stamp: 'PabloTesone 10/14/2019 16:54'!flushEntryBuffer	self critical: [		| initialPosition initialLocalName fileStream |		self entryBuffer isEmpty ifTrue: [ ^self ].						[ fileStream := ZnCharacterWriteStream on: fileReference binaryWriteStream encoding: #utf8. ] on: ReadOnlyFileException do: [ :anException |			fileStream ifNotNil: [ fileStream close ].			^ self		 ].				[ | anEntryWriter |			fileStream setToEnd.						initialPosition := fileStream position.			initialLocalName := self entryBuffer first value.			anEntryWriter := self newEntryWriter.			[ self entryBuffer isEmpty ] whileFalse: [				| next entry |				next := self entryBuffer removeFirst.				entry := next key.				"Write entry to file"				anEntryWriter					on: fileStream					nextEntryPut: entry.				].			"In Linux it was necessary to explicitly flush the file stream"			fileStream flush.						lastStreamPosition := fileStream position.			] ensure: [ fileStream close ].			self refreshEntryPositionsByLocalNameStartingAt: initialPosition since: initialLocalName ].! !